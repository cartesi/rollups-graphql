// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type AddressFilterInput struct {
	Eq  *string             `json:"eq,omitempty"`
	Ne  *string             `json:"ne,omitempty"`
	In  []*string           `json:"in,omitempty"`
	Nin []*string           `json:"nin,omitempty"`
	And []*ConvenientFilter `json:"and,omitempty"`
	Or  []*ConvenientFilter `json:"or,omitempty"`
}

// Filter object to restrict results depending on input properties
type AppFilter struct {
	// Filter only inputs with index lower than a given value
	IndexLowerThan *int `json:"indexLowerThan,omitempty"`
	// Filter only inputs with index greater than a given value
	IndexGreaterThan *int `json:"indexGreaterThan,omitempty"`
	// Filter only apps with name
	Name *string `json:"name,omitempty"`
	// Filter only apps with address
	Address *string `json:"address,omitempty"`
}

type Application struct {
	// Application ID
	ID string `json:"id"`
	// Application name
	Name string `json:"name"`
	// Application Address
	Address string `json:"address"`
}

type BooleanFilterInput struct {
	Eq  *bool               `json:"eq,omitempty"`
	Ne  *bool               `json:"ne,omitempty"`
	And []*ConvenientFilter `json:"and,omitempty"`
	Or  []*ConvenientFilter `json:"or,omitempty"`
}

type ConvenientFilter struct {
	Destination *AddressFilterInput `json:"destination,omitempty"`
	Executed    *BooleanFilterInput `json:"executed,omitempty"`
	And         []*ConvenientFilter `json:"and,omitempty"`
	Or          []*ConvenientFilter `json:"or,omitempty"`
}

// Filter object to restrict results depending on input properties
type InputFilter struct {
	// Filter only inputs with index lower than a given value
	IndexLowerThan *int `json:"indexLowerThan,omitempty"`
	// Filter only inputs with index greater than a given value
	IndexGreaterThan *int `json:"indexGreaterThan,omitempty"`
	// Filter only inputs with the message sender
	MsgSender *string `json:"msgSender,omitempty"`
	// Filter only inputs from 'inputbox' or 'espresso'
	Type *string `json:"type,omitempty"`
}

// Page metadata for the cursor-based Connection pagination pattern
type PageInfo struct {
	// Cursor pointing to the first entry of the page
	StartCursor *string `json:"startCursor,omitempty"`
	// Cursor pointing to the last entry of the page
	EndCursor *string `json:"endCursor,omitempty"`
	// Indicates if there are additional entries after the end curs
	HasNextPage bool `json:"hasNextPage"`
	// Indicates if there are additional entries before the start curs
	HasPreviousPage bool `json:"hasPreviousPage"`
}

type CompletionStatus string

const (
	CompletionStatusUnprocessed                CompletionStatus = "UNPROCESSED"
	CompletionStatusAccepted                   CompletionStatus = "ACCEPTED"
	CompletionStatusRejected                   CompletionStatus = "REJECTED"
	CompletionStatusException                  CompletionStatus = "EXCEPTION"
	CompletionStatusMachineHalted              CompletionStatus = "MACHINE_HALTED"
	CompletionStatusCycleLimitExceeded         CompletionStatus = "CYCLE_LIMIT_EXCEEDED"
	CompletionStatusTimeLimitExceeded          CompletionStatus = "TIME_LIMIT_EXCEEDED"
	CompletionStatusPayloadLengthLimitExceeded CompletionStatus = "PAYLOAD_LENGTH_LIMIT_EXCEEDED"
)

var AllCompletionStatus = []CompletionStatus{
	CompletionStatusUnprocessed,
	CompletionStatusAccepted,
	CompletionStatusRejected,
	CompletionStatusException,
	CompletionStatusMachineHalted,
	CompletionStatusCycleLimitExceeded,
	CompletionStatusTimeLimitExceeded,
	CompletionStatusPayloadLengthLimitExceeded,
}

func (e CompletionStatus) IsValid() bool {
	switch e {
	case CompletionStatusUnprocessed, CompletionStatusAccepted, CompletionStatusRejected, CompletionStatusException, CompletionStatusMachineHalted, CompletionStatusCycleLimitExceeded, CompletionStatusTimeLimitExceeded, CompletionStatusPayloadLengthLimitExceeded:
		return true
	}
	return false
}

func (e CompletionStatus) String() string {
	return string(e)
}

func (e *CompletionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompletionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompletionStatus", str)
	}
	return nil
}

func (e CompletionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
